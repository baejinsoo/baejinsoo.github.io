---
title: "JAVA(6) 추상 클래스,인터페이스"
excerpt: "Do it! 자바 프로그래밍 입문"
categories:
  - JAVA
last_modified_at: 2021-01-16
toc: true
sitemap:
  changefreq: daily
  priority: 1.0
---

### 추상 클래스

- 추상 메서드(구현 코드가 없이 선언부만 있는 메서드)를 포함한 클래스
- abstract 예약어 사용
- 추상 클래스는 new (인스턴스화) 불가능

```java
public abstract class Computer {
    public abstract void display();
    public abstract void typing();
}
// 모든 메서드가 구현되었다고 해도 클래스에 abstract 키워드를 사용하면 추상 메서드
```

- 추상 클래스는 주로 상속의 상위클래스로 사용됨
- 추상 메서드 : 하위 클래스가 구현해야 하는 메서드(하위 클래스에 따라 재정의 가능)

![image-abstract1](../../assets\images\abstract1.png)

##### 템플릿 메서드

추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의 해 놓은 메서드

final로 선언하여 재정의 할 수 없게 함

##### 템플릿 메서드 패턴

- 디자인 패턴의 일종
- 프레임 워크에서 많이 사용되는 설계 패턴
- 추상 클래스로 선언된 상위 클래스에서 추상 메서드를 이용하여 전체 구현의 흐름(시나리오)을 정의하고 구체적인 각 메서드 구현은 하위 클래스에 위임함

```java
public abstract class Car {
    public abstract void drive();
    public abstract void stop();
    
    public void startCar() {
        System.out.println("시동을 켭니다")
    }
    
    public void turnOff() {
        System.out.println("시동을 끕니다")
    }
    
    // 템플릿 메서드
    final public void run() { // 구현의 흐름(시나리오) 정의
        startCar();
        dirve();
        stop();
        turnOff();
    }
}
```

#### final

`final` 변수는 값이 변경될 수 없는 상수

`public static final double PI = 3.14;` // 오직 한번만 값을 할당 할 수 있음

final 메서드는 하위 클래스에서 재정의(overriding) 할 수 없음

final 클래스는 더 이상 상속되지 않음



#### 템플릿 메서드 활용 예제

player가 있고 레벨에 따라 run(), jump(), turn() 기능이 가능하다.

- 초보자 레벨: 천천히 달린다.(run() 가능)
- 중급자 레벨 : 빠르게 달리고 (run() 가능), 점프 (jump() 가능) 
- 고급자 레벨 : 엄청 빠르게 달리고(run() 가능), 점프(jump() 가능) 하고 
               한 바퀴 돌 수 있습니다.(turn() 가능)

*객체지향으로 만들지 않으면 복잡한 if문으로 만들어야 하고, 새로 추가 되었을 때 복잡해진다.*

###### PlayerLevel 클래스

```java
public abstract class PlayerLevel {
	
	public abstract void run();
	public abstract void jump();
	public abstract void turn();
	public abstract void showLevelMessage();
	
	
	final public void go(int count) {
		run();
		for(int i = 0; i<count; i++) {
			jump();
		}
		turn();
	}

}
```

###### Beginner, Advanced, Super 클래스

```java
public class BeginnerLevel extends PlayerLevel{

	public void run() {
		System.out.println("천천히 달립니다.");
	}
	public void jump() {
		System.out.println("jump 못하지롱");
	}
	public void turn() {
		System.out.println("turn 못하지롱");
	}
	public void showLevelMessage() {
		System.out.println("****** 초급자 레벨입니다. ******");
	}
}
```

###### Player 클래스

```java
public class Player {
	
	private PlayerLevel level;
	
	public Player(){
		level = new BeginnerLevel();
		level.showLevelMessage();
	}
	
	public PlayerLevel getLevel() {
		return level;
	}
	
	public void upgradeLevel( PlayerLevel level ) {
		this.level = level;
		level.showLevelMessage();
	}
	
	public void play(int count) {
		level.go(count);
	}
}
```

###### play test -main

```java
public class MainBoardPlay {

	public static void main(String[] args) {

		Player player = new Player();
		player.play(1);
		
		AdvancedLevel aLevel = new AdvancedLevel();
		player.upgradeLevel(aLevel);
		player.play(2);
		
		SuperLevel sLevel = new SuperLevel();
		player.upgradeLevel(sLevel);
		player.play(3);
	}
}
```

=> 레벨을 추가할때도 if문 하나없이 클래스 추가하면 편리하다.

​	시간절약, 필드와 메서드 이름을 통일해서 유지보수성을 높이고 통일성 유지 가능



### 인터페이스

