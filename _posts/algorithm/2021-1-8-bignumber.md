---
title: "큰 수의 법칙"
excerpt: "Greedy"
categories:
  - 알고리즘 문제풀기
last_modified_at: 2021-01-08
---

### [큰 수의 법칙]

**<문제>**
동빈이의 큰수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 방법이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때, M이 8이고 K가 3이라고 가정하자.

이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다. 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고 K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.

결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

**<입력 조건>**

- 첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000) 의 자연수가 주어지며 각자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
  단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
  입력으로 주어지는 K는 항상 M보다 작거나 같다.

**<출력 조건>**

- 첫째 줄에 동빈이의 큰수의 법칙에 따라 더해진 답을 출력한다.

**<입력 예시>**                                       **<출력 예시>**

- 5 8 3                                            46
  2 4 5 4 6

---

##### 해결방법:  배열을 정렬해준뒤 제일큰값과 두번째로 큰값을 저장 후 M 을 하나씩 빼며 조건에 맞게 결과값을 더해나간다.

```python
N, M, K = map(int, input().split())
num_list = list(map(int, input().split()))

result = 0
temp = 0
num_list.sort()
first = num_list[N-1]
second = num_list[N-2]

while M>0:
    if temp != K:
        result += first
        temp+=1
        M-=1
    else:
        temp = 0
        result += second
        M-=1
print(result)
```

##### 위의 방식대로 한다면 시간초과 오류를 받을 수 있음.

더 효율적인 방법으로 풀려면 *반복되는 수열*에 대해서 파악해야 한다.

최대값이 K번 더해지고 두번째값이 1번 더해지는 K+1 번이 반복되는 것을 확인 할 수 있다.

```python
count = int(M / (K+1)) * k
count += M % (K+1)
```

##### 풀이방법

```python
N, M, K = map(int, input().split())
num_list = list(map(int, input().split()))

num_list.sort()
first = num_list[N-1]
second = num_list[N-2]

# 가장 큰 수가 더해지는 횟수
count = int(M / (K+1)) * k
count += M % (K+1)

result = 0
result += count * first
result += (M-count) * second

print(result)
```

